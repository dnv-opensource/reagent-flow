shadow$provide.module$node_modules$react$cjs$react_jsx_runtime_development = function(global, require, module, exports) {
  (function() {
    function error(format) {
      for (var _len2 = arguments.length, args = Array(1 < _len2 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      printWarning("error", format, args);
    }
    function printWarning(level, format, args) {
      var stack = ReactSharedInternals.ReactDebugCurrentFrame.getStackAddendum();
      "" !== stack && (format += "%s", args = args.concat([stack]));
      args = args.map(function(item) {
        return String(item);
      });
      args.unshift("Warning: " + format);
      Function.prototype.apply.call(console[level], console, args);
    }
    function getComponentNameFromType(type) {
      if (null == type) {
        return null;
      }
      "number" === typeof type.tag && error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
      if ("function" === typeof type) {
        return type.displayName || type.name || null;
      }
      if ("string" === typeof type) {
        return type;
      }
      switch(type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
      }
      if ("object" === typeof type) {
        switch(type.$$typeof) {
          case REACT_CONTEXT_TYPE:
            return (type.displayName || "Context") + ".Consumer";
          case REACT_PROVIDER_TYPE:
            return (type._context.displayName || "Context") + ".Provider";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {
            }
        }
      }
      return null;
    }
    function disabledLog() {
    }
    function disableLogs() {
      if (0 === disabledDepth) {
        prevLog = console.log;
        prevInfo = console.info;
        prevWarn = console.warn;
        prevError = console.error;
        prevGroup = console.group;
        prevGroupCollapsed = console.groupCollapsed;
        prevGroupEnd = console.groupEnd;
        var props = {configurable:!0, enumerable:!0, value:disabledLog, writable:!0};
        Object.defineProperties(console, {info:props, log:props, warn:props, error:props, group:props, groupCollapsed:props, groupEnd:props});
      }
      disabledDepth++;
    }
    function reenableLogs() {
      disabledDepth--;
      if (0 === disabledDepth) {
        var props = {configurable:!0, enumerable:!0, writable:!0};
        Object.defineProperties(console, {log:assign({}, props, {value:prevLog}), info:assign({}, props, {value:prevInfo}), warn:assign({}, props, {value:prevWarn}), error:assign({}, props, {value:prevError}), group:assign({}, props, {value:prevGroup}), groupCollapsed:assign({}, props, {value:prevGroupCollapsed}), groupEnd:assign({}, props, {value:prevGroupEnd})});
      }
      0 > disabledDepth && error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    function describeBuiltInComponentFrame(name, source, ownerFn) {
      if (void 0 === prefix) {
        try {
          throw Error();
        } catch (x) {
          prefix = (source = x.stack.trim().match(/\n( *(at )?)/)) && source[1] || "";
        }
      }
      return "\n" + prefix + name;
    }
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry) {
        return "";
      }
      var frame = componentFrameCache.get(fn);
      if (void 0 !== frame) {
        return frame;
      }
      reentry = !0;
      frame = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var previousDispatcher = ReactCurrentDispatcher.current;
      ReactCurrentDispatcher.current = null;
      disableLogs();
      try {
        if (construct) {
          if (construct = function() {
            throw Error();
          }, Object.defineProperty(construct.prototype, "props", {set:function() {
            throw Error();
          }}), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(construct, []);
            } catch (x) {
              var control = x;
            }
            Reflect.construct(fn, [], construct);
          } else {
            try {
              construct.call();
            } catch (x) {
              control = x;
            }
            fn.call(construct.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (x) {
            control = x;
          }
          fn();
        }
      } catch (sample) {
        if (sample && control && "string" === typeof sample.stack) {
          for (var sampleLines = sample.stack.split("\n"), controlLines = control.stack.split("\n"), s = sampleLines.length - 1, c = controlLines.length - 1; 1 <= s && 0 <= c && sampleLines[s] !== controlLines[c];) {
            c--;
          }
          for (; 1 <= s && 0 <= c; s--, c--) {
            if (sampleLines[s] !== controlLines[c]) {
              if (1 !== s || 1 !== c) {
                do {
                  if (s--, c--, 0 > c || sampleLines[s] !== controlLines[c]) {
                    var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                    fn.displayName && _frame.includes("\x3canonymous\x3e") && (_frame = _frame.replace("\x3canonymous\x3e", fn.displayName));
                    "function" === typeof fn && componentFrameCache.set(fn, _frame);
                    return _frame;
                  }
                } while (1 <= s && 0 <= c);
              }
              break;
            }
          }
        }
      } finally {
        reentry = !1, ReactCurrentDispatcher.current = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
      }
      control = (control = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(control) : "";
      "function" === typeof fn && componentFrameCache.set(fn, control);
      return control;
    }
    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
      if (null == type) {
        return "";
      }
      if ("function" === typeof type) {
        return source = type.prototype, describeNativeComponentFrame(type, !(!source || !source.isReactComponent));
      }
      if ("string" === typeof type) {
        return describeBuiltInComponentFrame(type);
      }
      switch(type) {
        case REACT_SUSPENSE_TYPE:
          return describeBuiltInComponentFrame("Suspense");
        case REACT_SUSPENSE_LIST_TYPE:
          return describeBuiltInComponentFrame("SuspenseList");
      }
      if ("object" === typeof type) {
        switch(type.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            return type = describeNativeComponentFrame(type.render, !1), type;
          case REACT_MEMO_TYPE:
            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
          case REACT_LAZY_TYPE:
            var payload = type._payload;
            type = type._init;
            try {
              return describeUnknownElementTypeFrameInDEV(type(payload), source, ownerFn);
            } catch (x) {
            }
        }
      }
      return "";
    }
    function setCurrentlyValidatingElement(element) {
      if (element) {
        var owner = element._owner;
        element = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
        ReactDebugCurrentFrame.setExtraStackFrame(element);
      } else {
        ReactDebugCurrentFrame.setExtraStackFrame(null);
      }
    }
    function checkKeyStringCoercion(value) {
      try {
        var JSCompiler_inline_result = !1;
      } catch (e) {
        JSCompiler_inline_result = !0;
      }
      if (JSCompiler_inline_result) {
        return JSCompiler_inline_result = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object", error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", JSCompiler_inline_result), "" + value;
      }
    }
    function defineKeyPropWarningGetter(props, displayName) {
      var warnAboutAccessingKey = function() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
      };
      warnAboutAccessingKey.isReactWarning = !0;
      Object.defineProperty(props, "key", {get:warnAboutAccessingKey, configurable:!0});
    }
    function defineRefPropWarningGetter(props, displayName) {
      var warnAboutAccessingRef = function() {
        specialPropRefWarningShown || (specialPropRefWarningShown = !0, error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
      };
      warnAboutAccessingRef.isReactWarning = !0;
      Object.defineProperty(props, "ref", {get:warnAboutAccessingRef, configurable:!0});
    }
    function jsxDEV(type, config, maybeKey, source, self) {
      var props = {}, key = null, ref = null;
      void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), key = "" + maybeKey);
      a: {
        if (hasOwnProperty.call(config, "key") && (maybeKey = Object.getOwnPropertyDescriptor(config, "key").get) && maybeKey.isReactWarning) {
          maybeKey = !1;
          break a;
        }
        maybeKey = void 0 !== config.key;
      }
      maybeKey && (checkKeyStringCoercion(config.key), key = "" + config.key);
      a: {
        if (hasOwnProperty.call(config, "ref") && (maybeKey = Object.getOwnPropertyDescriptor(config, "ref").get) && maybeKey.isReactWarning) {
          maybeKey = !1;
          break a;
        }
        maybeKey = void 0 !== config.ref;
      }
      maybeKey && (ref = config.ref, "string" === typeof config.ref && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self && (maybeKey = getComponentNameFromType(ReactCurrentOwner.current.type), didWarnAboutStringRefs[maybeKey] || (error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', 
      getComponentNameFromType(ReactCurrentOwner.current.type), config.ref), didWarnAboutStringRefs[maybeKey] = !0)));
      for (propName in config) {
        hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName) && (props[propName] = config[propName]);
      }
      if (type && type.defaultProps) {
        for (propName in config = type.defaultProps, config) {
          void 0 === props[propName] && (props[propName] = config[propName]);
        }
      }
      if (key || ref) {
        var propName = "function" === typeof type ? type.displayName || type.name || "Unknown" : type;
        key && defineKeyPropWarningGetter(props, propName);
        ref && defineRefPropWarningGetter(props, propName);
      }
      type = {$$typeof:REACT_ELEMENT_TYPE, type, key, ref, props, _owner:ReactCurrentOwner.current, _store:{}};
      Object.defineProperty(type._store, "validated", {configurable:!1, enumerable:!1, writable:!0, value:!1});
      Object.defineProperty(type, "_self", {configurable:!1, enumerable:!1, writable:!1, value:self});
      Object.defineProperty(type, "_source", {configurable:!1, enumerable:!1, writable:!1, value:source});
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function setCurrentlyValidatingElement$1(element) {
      if (element) {
        var owner = element._owner;
        element = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
        ReactDebugCurrentFrame$1.setExtraStackFrame(element);
      } else {
        ReactDebugCurrentFrame$1.setExtraStackFrame(null);
      }
    }
    function isValidElement(object) {
      return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function getDeclarationErrorAddendum() {
      if (ReactCurrentOwner$1.current) {
        var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
        if (name) {
          return "\n\nCheck the render method of `" + name + "`.";
        }
      }
      return "";
    }
    function getSourceInfoErrorAddendum(source) {
      return void 0 !== source ? "\n\nCheck your code at " + source.fileName.replace(/^.*[\\\/]/, "") + ":" + source.lineNumber + "." : "";
    }
    function validateExplicitKey(element, parentType) {
      if (element._store && !element._store.validated && null == element.key) {
        element._store.validated = !0;
        var currentComponentErrorInfo = getDeclarationErrorAddendum();
        currentComponentErrorInfo || (parentType = "string" === typeof parentType ? parentType : parentType.displayName || parentType.name) && (currentComponentErrorInfo = "\n\nCheck the top-level render call using \x3c" + parentType + "\x3e.");
        ownerHasKeyUseWarning[currentComponentErrorInfo] || (ownerHasKeyUseWarning[currentComponentErrorInfo] = !0, parentType = "", element && element._owner && element._owner !== ReactCurrentOwner$1.current && (parentType = " It was passed a child from " + getComponentNameFromType(element._owner.type) + "."), setCurrentlyValidatingElement$1(element), error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, 
        parentType), setCurrentlyValidatingElement$1(null));
      }
    }
    function validateChildKeys(node, parentType) {
      if ("object" === typeof node) {
        if (isArrayImpl(node)) {
          for (var i = 0; i < node.length; i++) {
            var child = node[i];
            isValidElement(child) && validateExplicitKey(child, parentType);
          }
        } else if (isValidElement(node)) {
          node._store && (node._store.validated = !0);
        } else if (node && (null === node || "object" !== typeof node ? i = null : (i = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node["@@iterator"], i = "function" === typeof i ? i : null), "function" === typeof i && i !== node.entries)) {
          for (node = i.call(node); !(i = node.next()).done;) {
            isValidElement(i.value) && validateExplicitKey(i.value, parentType);
          }
        }
      }
    }
    function validatePropTypes(element) {
      var type = element.type;
      if (null !== type && void 0 !== type && "string" !== typeof type) {
        var propTypes;
        if ("function" === typeof type || "object" === typeof type && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
          if (propTypes = type.propTypes) {
            var name = getComponentNameFromType(type), values = element.props, has = Function.call.bind(hasOwnProperty), typeSpecName;
            for (typeSpecName in propTypes) {
              if (has(propTypes, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if ("function" !== typeof propTypes[typeSpecName]) {
                    var err = Error((name || "React class") + ": prop type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof propTypes[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = propTypes[typeSpecName](values, typeSpecName, name, "prop", null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                !error$1 || error$1 instanceof Error || (setCurrentlyValidatingElement(element), error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", name || "React class", "prop", typeSpecName, typeof error$1), setCurrentlyValidatingElement(null));
                error$1 instanceof Error && !(error$1.message in loggedTypeFailures) && (loggedTypeFailures[error$1.message] = !0, setCurrentlyValidatingElement(element), error("Failed %s type: %s", "prop", error$1.message), setCurrentlyValidatingElement(null));
              }
            }
          } else {
            void 0 === type.PropTypes || propTypesMisspellWarningShown || (propTypesMisspellWarningShown = !0, element = getComponentNameFromType(type), error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", element || "Unknown"));
          }
          "function" !== typeof type.getDefaultProps || type.getDefaultProps.isReactClassApproved || error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
    }
    function validateFragmentProps(fragment) {
      for (var keys = Object.keys(fragment.props), i = 0; i < keys.length; i++) {
        var key = keys[i];
        if ("children" !== key && "key" !== key) {
          setCurrentlyValidatingElement$1(fragment);
          error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
          setCurrentlyValidatingElement$1(null);
          break;
        }
      }
      null !== fragment.ref && (setCurrentlyValidatingElement$1(fragment), error("Invalid attribute `ref` supplied to `React.Fragment`."), setCurrentlyValidatingElement$1(null));
    }
    function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
      var validType = "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || 
      type.$$typeof === REACT_MODULE_REFERENCE || void 0 !== type.getModuleId) ? !0 : !1;
      if (!validType) {
        var info = "";
        if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length) {
          info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
        }
        var sourceInfo = getSourceInfoErrorAddendum(source);
        info = sourceInfo ? info + sourceInfo : info + getDeclarationErrorAddendum();
        null === type ? sourceInfo = "null" : isArrayImpl(type) ? sourceInfo = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (sourceInfo = "\x3c" + (getComponentNameFromType(type.type) || "Unknown") + " /\x3e", info = " Did you accidentally export a JSX literal instead of a component?") : sourceInfo = typeof type;
        error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", sourceInfo, info);
      }
      key = jsxDEV(type, props, key, source, self);
      if (null == key) {
        return key;
      }
      if (validType && (validType = props.children, void 0 !== validType)) {
        if (isStaticChildren) {
          if (isArrayImpl(validType)) {
            for (isStaticChildren = 0; isStaticChildren < validType.length; isStaticChildren++) {
              validateChildKeys(validType[isStaticChildren], type);
            }
            Object.freeze && Object.freeze(validType);
          } else {
            error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
          }
        } else {
          validateChildKeys(validType, type);
        }
      }
      hasOwnProperty.call(props, "key") && (isStaticChildren = getComponentNameFromType(type), validType = Object.keys(props).filter(function(k) {
        return "key" !== k;
      }), props = 0 < validType.length ? "{key: someKey, " + validType.join(": ..., ") + ": ...}" : "{key: someKey}", didWarnAboutKeySpread[isStaticChildren + props] || (validType = 0 < validType.length ? "{" + validType.join(": ..., ") + ": ...}" : "{}", error('A props object containing a "key" prop is being spread into JSX:\n  let props \x3d %s;\n  \x3c%s {...props} /\x3e\nReact keys must be passed directly to JSX without using spread:\n  let props \x3d %s;\n  \x3c%s key\x3d{someKey} {...props} /\x3e', 
      props, isStaticChildren, validType, isStaticChildren), didWarnAboutKeySpread[isStaticChildren + props] = !0));
      type === REACT_FRAGMENT_TYPE ? validateFragmentProps(key) : validatePropTypes(key);
      return key;
    }
    var React = require("module$node_modules$react$index"), REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = 
    Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    var REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
    var assign = Object.assign, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
    disabledLog.__reactDisabledLog = !0;
    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher, prefix, reentry = !1;
    var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
    var hasOwnProperty = Object.prototype.hasOwnProperty, loggedTypeFailures = {}, ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame, isArrayImpl = Array.isArray, ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner, RESERVED_PROPS = {key:!0, ref:!0, __self:!0, __source:!0}, specialPropKeyWarningShown, specialPropRefWarningShown;
    var didWarnAboutStringRefs = {};
    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner, ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
    var propTypesMisspellWarningShown = !1;
    var ownerHasKeyUseWarning = {}, didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsx = function(type, props, key) {
      return jsxWithValidation(type, props, key, !1);
    };
    exports.jsxs = function(type, props, key) {
      return jsxWithValidation(type, props, key, !0);
    };
  })();
};

//# sourceMappingURL=module$node_modules$react$cjs$react_jsx_runtime_development.js.map
